# You-Dont-Know-JS

chapter-1: 

在非严格模式下，`LHS` 调用查找不到变量时会创建一个全局变量，`RHS` 查找不到变量时会抛出 `ReferenceError`。 在严格模式下，`LHS` 和 `RHS` 查找不到变量时都会抛出 `ReferenceError`。

对于 `var a = 10` 这条赋值语句，实际上是为了查找变量 `a`， 并且将 10 这个数值赋予它，这就是 `LHS` 查询。 对于 `console.log(a)` 这条语句，实际上是为了查找 `a` 的值并将其打印出来，这是 `RHS` 查询。

---
chapter-2:

`JavaScript` 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析,并预先确定所有变量和函数的定义位置,才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了 `eval(..)` 或 `with` ,它只能简单地假设关于标识符位置的判断都是无效的,因为无法在词法分析阶段明确知道 `eval(..)` 会接收到什么代码,这些代码会如何对作用域进行修改,也无法知道传递给 `with` 用来创建新词法作用域的对象的内容到底是什么。

如果代码中大量使用 eval(..) 或 with ,那么运行起来一定会变得非常慢。无论引擎多聪明,试图将这些悲观情况的副作用限制在最小范围内,也无法避免如果没有这些优化,代码会运行得更慢这个事实。

---

chapter-03:

匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。

1. 匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。

2. 如果没有函数名,当函数需要引用自身时只能使用已经过期的 `arguments.callee` 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。

3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

值得注意的是，在 `if` 和 `for` 块中创建的变量会被绑定在外部作用域。很可惜，`JavaScript` 表面上好像并没有创建块作用域的工具，除非你深入研究。在  `ES6` 之前， `with` 和 `try/catch` 可以创建块作用域，`ES6` 中引入了 `let` 关键字，let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。换句话说, `let` 为其声明的变量隐式地了所在的块作用域。

`ES6` 中引入了 `const` 关键字用于声明一个常量。比如 `const a = 10；` 。

---

chapter-04:

函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是函数会首先被提升,然后才是变量。
